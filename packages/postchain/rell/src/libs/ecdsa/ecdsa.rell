function recover(hash: byte_array, signature: byte_array) {
    val result = try_recover(hash, signature);
    _throw_error(result[1]);
    return result[0];
    
}

function try_recover(hash: byte_array, signature: byte_array):(text, recover_error) {
    if(signature.size() == 65) {
        val r: byte_array;
        val s: byte_array;
        val v: integer;
        r = byte_array((signature.to_hex().sub(0,64)));
        s = byte_array((signature.to_hex().sub(64,128)));
        v = binary.byteToUint(byte_array(signature.to_hex().sub(128,130)));
        return _try_recover_vrs(hash, v, r, s);
    } else if (signature.size() == 64) {
        val r: byte_array;
        val vs: byte_array;
        r = byte_array((signature.to_hex().sub(0,64)));
        vs = byte_array((signature.to_hex().sub(64,128)));
        return _try_recover_rvs(hash,r,vs);
    } else {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000", recover_error.invalid_signature_length);
    }
}

function _try_recover_rvs(hash: byte_array, r: byte_array, vs: byte_array)  {
    val s: byte_array = binary.bitAnd([vs,x"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"]);
    val v: integer = binary.byteToUint(binary.bitRightShift(vs,255)) + 27;
    return _try_recover_vrs(hash,v,r,s);  
}

function _try_recover_vrs(hash: byte_array, v: integer, r:byte_array, s:byte_array):(text, recover_error) {        
    if(binary.compare(s,x"7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0") == binary.rule_operator.lt) {
        return("0x0000000000000000000000000000000000000000000000000000000000000000", recover_error.invalid_signature_s);
    }
    if(v != 27 and v!= 28) {
        log("Invalid Signature");
        return("0x0000000000000000000000000000000000000000000000000000000000000000", recover_error.invalid_signature_v);
    }
    val pubkey_64bytes = eth_ecrecover(
        r, 
        s, 
        v-v,
        hash);
    val _address: byte_array = keccak256(pubkey_64bytes).sub(12);
    val recovered_address = "0x" + _address.to_hex();
    return (recovered_address,recover_error.no_error);
}

function _throw_error(error: recover_error) {
    if (error == recover_error.invalid_signature_s) {
        log("ECDSA: invalid signature");
    } else if (error == recover_error.invalid_signature_length) {
        log("ECDSA: invalid signature length");
    } else if (error == recover_error.invalid_signature_s) {
        log("ECDSA: invalid signature 's' value");
    } else if (error == recover_error.invalid_signature_v) {
        log("ECDSA: invalid signature 'v' value");
    }
}

function to_eth_signed_msg_hash(msg: byte_array): byte_array {
    return keccak256(("\u0019Ethereum Signed Message:\n" + msg.size().to_text() + msg).to_bytes());
}

function to_typed_data_hash(domainSeparator: byte_array, structHash: byte_array) {
    return keccak256(("\u0019x19\u0019x01" + domainSeparator + structHash).to_bytes());
}