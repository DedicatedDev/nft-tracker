
function _get_contracts(chain: text) {
    return contract @* { .chain == chain } ( .chain, .address, .type);
}

function _get_nft_history(chain: text, contract: byte_array, id: integer, cursor: page_cursor) {
    val nft = nft @? { chain, contract, id };
    
    if (empty(nft)) return null_page();
    
    val nft_history = ownership @* { nft, .rowid >= cursor.after_rowid } (
        data = (
            owner = .owner.id
        ).to_gtv(),
        rowid = .rowid
    ) limit fetch_data_size(cursor);
    
    return _make_page(nft_history, cursor); 
}

 function _get_user_nfts(owner_id: byte_array, cursor: page_cursor) {
    val owner = owner @? { owner_id };
    if (empty(owner)) return null_page();
    
    val user_nfts = current_owner @* { 
        .ownership.owner == owner, 
        .rowid >= cursor.after_rowid
    } (
        data = (
            chain = .nft.chain,
            contract = .nft.contract,
            id = .nft.id
        ).to_gtv(),
        rowid = .rowid
    ) limit fetch_data_size(cursor);
    
    return _make_page(user_nfts,cursor);
}

function _get_nfts_by_token(chain: text, contract: byte_array, cursor: page_cursor) {
    val nft_collection = ownership @* {
        .nft.chain == chain,
        .nft.contract == contract,
        .rowid >= cursor.after_rowid 
    } (
        data = (
            chain = .nft.chain,
            contract = .nft.contract,
            id = .nft.id
        ).to_gtv(),
        rowid = .rowid
    ) limit fetch_data_size(cursor);
    
    return _make_page(nft_collection,cursor);
}

function _make_page(query_data: list<(data: gtv, rowid: rowid)>, cursor: page_cursor) {
    if (query_data.size() == 0) return null_page();
    
    if (query_data.size() > page_size(cursor)) {
        val query_data_to_return = query_data.sub(0, query_data.size()-1);
        val last_item = query_data_to_return[query_data_to_return.size()-1];
        val last_item_rowid = last_item.rowid;
        val next_cursor = page_cursor(
            page_size = cursor.page_size,
            after_rowid = last_item_rowid
        );

        return (
            cursor = ( 
                next = encode_cursor(next_cursor)
            ),
            data = query_data_to_return @* {} .data
        );
    } else {
        return (
            cursor = ( 
                next = null
            ),
            data = query_data  @* {} .data
        );
    }
}

function null_page() = (
    cursor = (
        next = null
    ),
    data = list<gtv>()
);

function encode_cursor(page_cursor) = page_cursor.to_bytes().to_base64();

function decode_cursor(cursor: text) = page_cursor.from_bytes(byte_array.from_base64(cursor));

function page_size(page_cursor) = min(MAX_PAGE_SIZE, page_cursor.page_size);

function fetch_data_size(page_cursor) = page_size(page_cursor) + 1;

