function _get_contracts(chain: text) {
    return contracts @* {.chain == chain} (.chain,.address,.type);
}

function _get_nft_history(chain: text, contract: byte_array, id: integer, cursor: page_cursor) {
    val nft = nft @? { chain, contract, id };
    if (empty(nft)) return null;
    val nft_histories = ownership @* { nft, .rowid >= cursor.after_rowid } (data=(owner = .owner.id).to_gtv(),row_id = .rowid) limit page_size(cursor);
    return _make_page(nft_histories,cursor); 
}

function _get_user_nfts(owner_id: byte_array, cursor: page_cursor) {
    val owner = owner @? { owner_id };
    if (empty(owner)) return null_page();
    val user_nfts = current_owner @* { .ownership.owner == owner,.rowid >= cursor.after_rowid } (
        data=(
            chain = .nft.chain,
            contract = .nft.contract,
            id = .nft.id
        ).to_gtv(),
        row_id = .rowid
    ) limit page_size(cursor);
    return _make_page(user_nfts,cursor);
}

function _get_nfts_by_token(chain: text, contract: byte_array, cursor: page_cursor) {
    val nft_collection = ownership @* {
        .nft.chain == chain,
        .nft.contract == contract,
        .rowid >= cursor.after_rowid }
        (
            data=(
                chain = .nft.chain,
                contract = .nft.contract,
                id = .nft.id
            ).to_gtv(),
            row_id = .rowid
        ) limit page_size(cursor);
    return _make_page(nft_collection,cursor);
}

function _make_page(query_data:list<(data: gtv, row_id: rowid)>, cursor: page_cursor) {

    if(query_data.size() == 0) return null_page();
    if (query_data.size() > min(MAX_PAGE_SIZE, page_size(cursor))) {
        val query_data_to_return = query_data.sub(0, query_data.size()-1);
        val last_item = query_data_to_return[query_data_to_return.size()-1];
        val last_item_rowid = last_item.row_id;
        val next_cursor = page_cursor(
            page_size = cursor.page_size,
            after_rowid = last_item_rowid
        );

        return (
            cursor = ( 
                next = next_cursor.to_bytes().to_base64()
            ),
            data = query_data_to_return @* {} .data
        );
    } else {
        return (
            cursor = ( 
                next = ""
            ),
            data = query_data  @* {} .data
        );
    }
}

function null_page() = (
    cursor = (
        next = null
    ),
    data = list<gtv>()
);

function next_cursor(cursor:text) = page_cursor.from_bytes(byte_array.from_base64(cursor));
function page_size(page_cursor) = min(MAX_PAGE_SIZE, page_cursor.page_size)+1;