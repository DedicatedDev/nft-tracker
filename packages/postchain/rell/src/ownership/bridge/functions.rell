function _get_contracts(chain: text) {
    return contracts @* {.chain == chain} (.chain,.address,.type);
}

function _get_nft_history(chain: text, contract: byte_array, id: integer, cursor: page_cursor) {
    val nft = nft @? { chain, contract, id };
    if (empty(nft)) return null;
    val data = ownership @* { nft, .rowid >= cursor.after_rowid } (nft_history(owner = .owner.id,rowid = .rowid).to_gtv()) limit cursor.page_size+1;
    return _manager_pagination(data,cursor); 
}

function _get_user_nfts(owner_id: byte_array, cursor: page_cursor) {
    val owner = owner @? { owner_id };
    if (empty(owner)) return null;
    val data = current_owner @* { .ownership.owner == owner,.rowid >= cursor.after_rowid } (
        user_nft(
            chain = .nft.chain,
            contract = .nft.contract,
            id = .nft.id,
            rowid = .rowid
        ).to_gtv()
    ) limit cursor.page_size+1;
    return _manager_pagination(data,cursor);
}

function _get_nfts_by_token(chain: text, contract: byte_array, cursor: page_cursor) {
    val data = ownership @* {
        .nft.chain == chain,
        .nft.contract == contract,
        .rowid >= cursor.after_rowid }
        (
            user_nft(
                chain = .nft.chain,
                contract = .nft.contract,
                id = .nft.id,
                rowid = .rowid
            ).to_gtv()
        ) limit cursor.page_size+1;
    return _manager_pagination(data,cursor);
}

function _manager_pagination(data:list<gtv>, cursor: page_cursor) {
    if(data.size() == 0) return null;
    if (data.size() > max(MAX_PAGE_SIZE, cursor.page_size)) {
        val data_to_return = data.sub(0, data.size()-1);
        val last_item = cursor_position.from_gtv(data_to_return[data_to_return.size()-1]);
        var next_cursor = cursor;
        next_cursor.after_rowid = last_item.rowid;
    
        return (
            cursor = ( 
                next = next_cursor.to_bytes().to_hex()
            ),
            data = data_to_return
        );
    } else {
        return (
            cursor = ( 
                next = ""
            ),
            data = data
        );
    }
}