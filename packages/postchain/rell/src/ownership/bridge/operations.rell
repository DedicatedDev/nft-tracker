operation add_contract(chain: text, address: pubkey, type: text) {
    _add_contract(chain, address, type);
}

operation transfer_ownership(chain: name, contract: byte_array, nft_id: integer, owner_id: byte_array, block_number: integer) {
    _transfer_ownership(chain, contract, nft_id, owner_id, block_number);
}

operation transfer_batch_ownership(
    chain:text, 
    contract_address: byte_array, 
    tokens: list<(token_id: integer, owner_id: byte_array, block_number: integer)>
) {

    /*
    Update ownership of multiple NFTs in a single transaction.
    */

    for (idx in range(tokens.size())) {
        _transfer_ownership(
            chain,
            contract_address,
            tokens[idx].token_id,
            tokens[idx].owner_id,
            tokens[idx].block_number
        );
    }

    /*
    Update trace status
    */
    val block_info = ownership @* { 
        .nft.chain == chain, 
        .nft.contract == contract_address 
    } ( @sort .block_number);

    if(block_info.size()>0){
        val _contract = contract @? { .chain == chain, .address == contract_address } ?: _add_contract(chain, contract_address, "");
        update trace_status @? { .contract == _contract} ( 
            last_block_number = block_info[block_info.size() - 1],
            mined_block_number = block_info[0]
        );
    }

}

operation report_mined(chain: text, contract_address: byte_array, status: boolean) {
    val _contract = contract @ { .chain == chain, .address == contract_address };
    update trace_status @? { .contract == _contract } ( 
        mined = status
    );
    
}