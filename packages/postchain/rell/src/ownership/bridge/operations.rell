operation add_contract(chain: text, address: pubkey, type: text) {
    _add_contract(chain, address, type);
}

operation transfer_ownership(chain: name, contract: byte_array, nft_id: integer, owner_id: byte_array, block_number: integer) {
    _transfer_ownership(chain, contract, nft_id, owner_id, block_number);
}

operation transfer_batch_complex_ownership( 
    tokens: list<(chain:text,
    contract_address: byte_array,
    type: text,
    token_id: integer,
    owner_id: byte_array,
    block_number: integer)>
) {
    var chain: text = "";
    var type: text = "";
    var contract_address: byte_array;
    for (token in tokens) {
        _transfer_ownership(
            token.chain,
            token.contract_address,
            token.token_id,
            token.owner_id,
            token.block_number
        );

        if(chain != token.chain or type != token.type) {
            chain = token.chain;
            contract_address = token.contract_address;
            type = token.type;
        }
    }
    
}

operation transfer_batch_ownership(
    chain:text, 
    contract_address: byte_array, 
    type: text,
    tokens: list<(token_id: integer, owner_id: byte_array, block_number: integer)>
) {
    /*
    Update ownership of multiple NFTs in a single transaction.
    */
    for (token in tokens) {
        _transfer_ownership(
            chain,
            contract_address,
            token.token_id,
            token.owner_id,
            token.block_number
        );
    }
    /*
    Update trace status.
    */
    _update_contract_sync_status(chain, contract_address,type);
}

operation update_contract_sync_status(  
   contracts: list<(chain:text, contract_address: byte_array, type:text)>
) {
    for (contract in contracts ) {
        _update_contract_sync_status(contract.chain, contract.contract_address, contract.type);
    }
}

operation update_chain_sync_status(chain:text, last_sync_block_number: integer) {
    _update_chain_sync_status(chain, last_sync_block_number);
}
