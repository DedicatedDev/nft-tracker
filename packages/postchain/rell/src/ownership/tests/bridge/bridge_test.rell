@test module;
import ^^^.tests.*;
function test_add_contract()  {
    log(rell.test.keypairs.alice);
    rell.test.tx().op(ownership.bridge.add_contract("eth_main", rell.test.keypairs.alice.pub, "ERC1155")).sign(rell.test.keypairs.alice).run();
    val contracts = ownership.bridge.contracts @* { 
        .chain == "eth_main",
        .pubkey == rell.test.keypairs.alice.pub,
        .type == "ERC1155"
    };
    assert_true(contracts.size() == 1);
}

function test_transfer_ownership()  {
    rell.test.tx().op(ownership.bridge.transfer_ownership("eth_main",rell.test.keypairs.alice.pub,1,rell.test.keypairs.bob.pub)).sign(rell.test.keypairs.alice).run();
}

//fetch nfts by contract address
function test_query_nfts_by_token() {
    create_ownership(
        "eth_main",
        rell.test.keypairs.bob.pub,
        1,
        rell.test.keypairs.alice.pub,
        rell.test.keypairs.alice
    );
    val result = ownership.bridge.get_nfts_by_token("eth_main",rell.test.keypairs.bob.pub);
    assert_true(result.size()==1);
    assert_equals(result[0].chain, "eth_main");
    assert_equals(result[0].contract,rell.test.keypairs.bob.pub);
}

//fetch nfts by owner 
function test_query_nfts_by_owner() {
    create_ownership(
        "eth_main",
        rell.test.keypairs.bob.pub,
        1,
        rell.test.keypairs.alice.pub,
        rell.test.keypairs.alice
    );
    val result = ownership.bridge.get_user_nfts(rell.test.keypairs.alice.pub);
    assert_false(empty(result));
}

//fetch nfts by owner 
function test_query_nfts_by_owner_empty() {
    val result = ownership.bridge.get_user_nfts(rell.test.keypairs.alice.pub);
    assert_true(empty(result));
}