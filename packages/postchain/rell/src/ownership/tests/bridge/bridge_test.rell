@test module;
import ^^^.tests.*;
function test_add_contract()  {
    val admin = admin_keypair();
    rell.test.tx().op(ownership.bridge.add_contract("eth_main", rell.test.keypairs.alice.pub, "ERC1155")).sign(admin).run();
    val contracts = ownership.bridge.contracts @* { 
        .chain == "eth_main",
        .address == rell.test.keypairs.alice.pub,
        .type == "ERC1155"
    };
    assert_true(contracts.size() == 1);
}

function test_transfer_ownership()  {
    val admin = admin_keypair();
    rell.test.tx().op(ownership.bridge.transfer_ownership("eth_main",rell.test.keypairs.alice.pub,1,rell.test.keypairs.bob.pub)).sign(admin).run();
}

function test_query_nft_history() {
    create_ownership(
        "eth_main",
        rell.test.keypairs.bob.pub,
        1,
        rell.test.keypairs.alice.pub
    );
    val quiz = ownership.bridge.query_info(
        query_params = ownership.bridge.nft_history_query(
            chain = "eth_main",
            contract = rell.test.keypairs.bob.pub,
            id = 1
        ).to_gtv(),
        cursor = ownership.bridge.page_cursor(
            page_size = 150,
            after_rowid = rowid.from_gtv((0).to_gtv())
        )
    );
    
    val result = ownership.bridge.get_nft_history(quiz);
    assert_true(result!!.data.size()==1);
}

// //fetch nfts by contract address
function test_query_nfts_by_token() {
    create_ownership(
        "eth_main",
        rell.test.keypairs.bob.pub,
        1,
        rell.test.keypairs.alice.pub
    );

    val quiz = ownership.bridge.query_info(
        query_params = ownership.bridge.nfts_collection_query(
            chain = "eth_main",
            contract = rell.test.keypairs.bob.pub
        ).to_gtv(),
        cursor = ownership.bridge.page_cursor(
            page_size = 150,
            after_rowid = rowid.from_gtv((0).to_gtv())
        )
    );

    val result = ownership.bridge.get_nfts_by_token(quiz);
    assert_true(result!!.data.size()==1);
    for (i in range(result!!.data.size())) {
        val expected = ownership.bridge.user_nft.from_gtv(result!!.data[i]);
        assert_equals(expected.chain,"eth_main");
        assert_equals(expected.contract,rell.test.keypairs.bob.pub);
    }
}

//fetch nfts by owner 
function test_query_nfts_by_owner() {
    create_ownership(
        "eth_main",
        rell.test.keypairs.bob.pub,
        1,
        rell.test.keypairs.alice.pub
    );

    val quiz = ownership.bridge.query_info(
        query_params = ownership.bridge.user_nfts_query (
            owner_id = rell.test.keypairs.alice.pub
        ).to_gtv(),
        cursor = ownership.bridge.page_cursor(
            page_size = 150,
            after_rowid = rowid.from_gtv((0).to_gtv())
        )
    );

    val result = ownership.bridge.get_user_nfts(quiz);
    assert_true(result!!.data.size()==1);
    for (i in range(result!!.data.size())) {
        val expected = ownership.bridge.user_nft.from_gtv(result!!.data[i]);
        assert_equals(expected.chain,"eth_main");
        assert_equals(expected.contract,rell.test.keypairs.bob.pub);
    }
}

// //fetch nfts by owner 
function test_query_nfts_by_owner_empty() {
    val quiz = ownership.bridge.query_info(
        query_params = ownership.bridge.user_nfts_query (
            owner_id = rell.test.keypairs.alice.pub
        ).to_gtv(),
        cursor = ownership.bridge.page_cursor(
            page_size = 150,
            after_rowid = rowid.from_gtv((0).to_gtv())
        )
    );

    val result = ownership.bridge.get_user_nfts(quiz);
    assert_true(empty(result));
}
