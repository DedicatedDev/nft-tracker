@test module;
import ^^^.tests.*;
function test_add_contract()  {
    val admin = admin_keypair();
    rell.test.tx().op(ownership.bridge.add_contract("eth_main", rell.test.keypairs.alice.pub, "ERC1155")).sign(admin).run();
    val contracts = ownership.bridge.contracts @* { 
        .chain == "eth_main",
        .pubkey == rell.test.keypairs.alice.pub,
        .type == "ERC1155"
    };
    assert_true(contracts.size() == 1);
}

function test_transfer_ownership()  {
    val admin = admin_keypair();
    rell.test.tx().op(ownership.bridge.transfer_ownership("eth_main",rell.test.keypairs.alice.pub,1,rell.test.keypairs.bob.pub)).sign(admin).run();
}

//fetch nfts by contract address
function test_query_nfts_by_token() {
    create_ownership(
        "eth_main",
        rell.test.keypairs.bob.pub,
        1,
        rell.test.keypairs.alice.pub
    );
    val result = ownership.bridge.get_nfts_by_token("eth_main",rell.test.keypairs.bob.pub,0,20);
    assert_true(result.size()==1);
    assert_equals(result[0].chain, "eth_main");
    assert_equals(result[0].contract,rell.test.keypairs.bob.pub);
}

//fetch nfts by owner 
function test_query_nfts_by_owner() {
    create_ownership(
        "eth_main",
        rell.test.keypairs.bob.pub,
        1,
        rell.test.keypairs.alice.pub
    );
    val result = ownership.bridge.get_user_nfts(rell.test.keypairs.alice.pub,0,20);
    assert_false(empty(result));
}

//fetch nfts by owner 
function test_query_nfts_by_owner_empty() {
    val result = ownership.bridge.get_user_nfts(rell.test.keypairs.alice.pub,0,20);
    assert_true(empty(result));
}

//fetch nfts by owner 
function test_get_contracts() {
    val result = ownership.bridge.get_contracts("eth_main");
    assert_true(empty(result));
}

// //test invalid pagination. 
// function test_invalid_pagination() {
//     ownership.bridge.get_user_nfts(rell.test.keypairs.alice.pub,-10,20);
// }