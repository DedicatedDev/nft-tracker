@test module;
import ^^^.tests.*;
val test_contract = x"29d8E29f41F82203b566047b5Ca4CD828F19E8E6";
function test_add_contract()  {
    val admin = admin_keypair();
    rell.test.tx().op(ownership.bridge.add_contract("eth_main", test_contract, "ERC1155")).sign(admin).run();
    val contracts = ownership.bridge.contracts @* { 
        .chain == "eth_main",
        .address == test_contract,
        .type == "ERC1155"
    };
    assert_true(contracts.size() == 1);
}

function test_transfer_ownership()  {
    val admin = admin_keypair();
    rell.test.tx().op(ownership.bridge.transfer_ownership("eth_main",test_contract,1,rell.test.keypairs.bob.pub)).sign(admin).run();
}

function test_query_nft_history() {
    create_ownership(
        "eth_main",
        test_contract,
        1,
        rell.test.keypairs.alice.pub
    );

    val cursor = ownership.bridge.page_cursor(
        page_size = 150,
        after_rowid = rowid.from_gtv((0).to_gtv())
    );
    val result = ownership.bridge.get_nft_history("eth_main",test_contract,1,cursor);
    assert_true(result!!.data.size()==1);
}

//fetch nfts by contract address
function test_query_nfts_by_token() {
    create_ownership(
        "eth_main",
        test_contract,
        1,
        rell.test.keypairs.alice.pub
    );

    val cursor = ownership.bridge.page_cursor(
        page_size = 150,
        after_rowid = rowid.from_gtv((0).to_gtv())
    );

    val result = ownership.bridge.get_nfts_by_token("eth_main",test_contract,cursor);
    assert_equals(clean_rowid(result!!.data), [
        ownership.bridge.user_nft(
          chain = "eth_main",
          contract = test_contract,
          id = 1,
          row_id = rowid.from_gtv((0).to_gtv())
        ).to_gtv()
    ]);
}

//fetch nfts by owner 
function test_query_nfts_by_owner() {
    create_ownership(
        "eth_main",
        test_contract,
        1,
        rell.test.keypairs.alice.pub
    );

    val cursor = ownership.bridge.page_cursor(
        page_size = 150,
        after_rowid = rowid.from_gtv((0).to_gtv())
    );

    val result = ownership.bridge.get_user_nfts(rell.test.keypairs.alice.pub,cursor);
    assert_equals(clean_rowid(result!!.data), [
        ownership.bridge.user_nft(
            chain = "eth_main",
            contract = test_contract,
            id = 1,
            row_id = rowid.from_gtv((0).to_gtv())
        ).to_gtv()
    ]);
}

//fetch nfts by owner 
function test_query_nfts_by_owner_empty() {
    val cursor = ownership.bridge.page_cursor(
        page_size = 150,
        after_rowid = rowid.from_gtv((0).to_gtv())
    );
    val result = ownership.bridge.get_user_nfts(rell.test.keypairs.alice.pub,cursor);
    assert_true(empty(result));
}

function test_query_nfts_batch() {
    create_batch_ownerships(150);
    val cursor = ownership.bridge.page_cursor(
        page_size = 100,
        after_rowid = rowid.from_gtv((0).to_gtv())
    );

    //Page 1
    val result = ownership.bridge.get_user_nfts(rell.test.keypairs.alice.pub,cursor);
    var expected_result = list<gtv>();
    for(i in range(100)) {
        expected_result.add(
            ownership.bridge.user_nft(
            chain = "eth_main",
            contract = test_contract,
            id = i,
            row_id = rowid.from_gtv((0).to_gtv())
        ).to_gtv());
    }
    assert_equals(clean_rowid(result!!.data),expected_result);

    // Page 2 
    val next_cursor = ownership.bridge.page_cursor.from_bytes(byte_array.from_base64(result.cursor.next));
    val result2 = ownership.bridge.get_user_nfts(rell.test.keypairs.alice.pub, next_cursor);
    expected_result.clear();
    for(i in range(99,150)) {
        expected_result.add(
            ownership.bridge.user_nft(
            chain = "eth_main",
            contract = test_contract,
            id = i,
            row_id = rowid.from_gtv((0).to_gtv())
        ).to_gtv());
    }
    assert_equals(clean_rowid(result2!!.data),expected_result);
}
